\documentclass{article}

\usepackage[english]{babel}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}


% For code snippets
\usepackage{listings}
\usepackage{color}

% Define colors for code
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegray},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstset{style=mystyle}

\title{
    \vspace{2in}
    \textmd{\textbf{Homework: Velocity Verlet \& Lennard-Jones potential}}\\
    \normalsize\vspace{0.1in}\small{Due on Friday 1.11 at 10:15am}\\
    \vspace{0.1in}
    \vspace{3in}
}

\author{Dominic Nieder, Awais Ahmed}
\date{\today}


\begin{document}
\maketitle

\section{Introduction}

This document explains the implementation of particle simulation that interact with a Lennard-Jones potential. First the code will be shortly elaborated upon and explained. Then the simulation results shall be discussed by taking a look at the time evolution of the total potential-, kinetic Energy as well as the temperature.



\section{Code and its Implementation}

\subsection{Particles}

The particles will all be captured by the class \texttt{Particle}. This class contains all particle positions, velocities and accelerations of seperate $x$- and $y$-coordinates. The class also contains the particles mass as well as the number of particles. In order to handle the Velocity Verlet integration sceem  another set of fields reserved for the accelerations \flqq$2$\frqq.

\begin{lstlisting}[language=python, caption={Particle class}]
class Particle:
    def __init__(
        self,
        n: int,
        m: float | int,
        x: NDArray[np.float64],
        y: NDArray[np.float64],
        vx: NDArray[np.float64],
        vy: NDArray[np.float64],
    ):
        self.n: int = n
        self.m: float = float(m)
        self.x: NDArray[np.float64] = np.array(x, dtype=np.float64)
        self.y: NDArray[np.float64] = np.array(y, dtype=np.float64)
        self.vx: NDArray[np.float64] = np.array(vx, dtype=np.float64)
        self.vy: NDArray[np.float64] = np.array(vy, dtype=np.float64)
        self.ax1: NDArray[np.float64] = np.zeros(n, dtype=np.float64)
        self.ay1: NDArray[np.float64] = np.zeros(n, dtype=np.float64)
        self.ax2: NDArray[np.float64] = np.zeros(n, dtype=np.float64)
        self.ay2: NDArray[np.float64] = np.zeros(n, dtype=np.float64)
\end{lstlisting}

\subsection{Initialization of Particles on a Grid}

This funciton gets called once to initiate all particles evenly distributed on a grid and with velocities in random directions. To instantiate the grid the numpy functions \texttt{meshgrid} and \textt{flatten} are used. 
\begin{lstlisting}[language=Python, caption=Particle Initialization on a Grid]
def initialize_particles_on_grid(
    n_particles: int, 
    box: tuple[float|int, float|int], 
    mass: float, 
    velocity: float,
    add_jitter: bool
) -> Particle:
    """
    Particles a regular grid within a given spacing.\n
    Random velocity directions. \n
    Returns: Particle with initialized positions and velocities. 
    """
    x_return = np.zeros(n_particles)
    y_return = np.zeros(n_particles)
    grid_sections = int(np.ceil(np.sqrt(n_particles))) 
    x_spacing = box[0]/grid_sections 
    y_spacing = box[1]/grid_sections
    x_positions, y_positions = np.meshgrid(
        np.arange(grid_sections) * x_spacing, 
        np.arange(grid_sections) * y_spacing
    )
    if add_jitter:
        x_positions += (np.random.rand(len(x_positions))-0.5)
        y_positions += (np.random.rand(len(y_positions))-0.5)
    x_return = x_positions.flatten()[:n_particles]
    y_return = y_positions.flatten()[:n_particles]
    vx = velocity * (np.random.rand(n_particles) - 0.5) * 2
    vy = velocity * (np.random.rand(n_particles) - 0.5) * 2
    return Particle(
        n=n_particles,
        m=mass,
        x=x_return,
        y=y_return,
        vx=vx,
        vy=vy
    )
\end{lstlisting}

\noindent
This function 


\subsection{Simulation \& Integration}

The \texttt{simulate} function takes a \texttt{Particle}, a \texttt{time} for the amout of time integrations, \texttt{dt} describing the timestep size, a \texttt{box} with periodic boundry conditions and a \texttt{data} array to save the particle states. The function contains iterates through time and calls the function \texttt{iterate} in which the positions get iterated to the next position $x(t)\rightarrow x(t+\Delta t)$, then saves the data of the position iteration.

\begin{lstlisting}[language=Python, caption=Simulation]
def simulate(
        particles: Particle, 
        time: int,
        dt: float|int, 
        box: tuple[float|int,float|int],
        data: NDArray[np.float64]
) -> NDArray[np.float64]:
    """
    Runs a simulation of n-particles in a box and saves phase-space coordinates to data.\n
    Returns data.
    """
    update_accelerations(particles,box)  # initial calculation for accelerations
    for t in range(time):  # iteration over all timestepps
        iterate(dt,particles,box)
        ### save data of interest
        data[t,0,:]=particles.x
        data[t,1,:]=particles.y
        data[t,2,:]=particles.vx
        data[t,3,:]=particles.vy
    return data
\end{lstlisting}

The function \texttt{iterate} 

\begin{lstlisting}[language=python, caption={Iterates the positions by Velocity Verlet}]
    
\end{lstlisting}

\subsection{Visualization and Animation}

\begin{lstlisting}[language=Python, caption=Animation Setup]


\end{lstlisting}


\noindent
Here:
\begin{itemize}
    \item \texttt{init}: Initializes the plot with empty data.
    \item \texttt{animate}: Updates particle positions for each frame.
\end{itemize}

\subsection{Energy Calculation and Plotting}

The energies of the particles are calculated and plotted as kinetic and potential energies over time. This visualization allows for monitoring the systemâ€™s energy changes throughout the simulation.

\begin{lstlisting}[language=Python, caption=Energy Plotting]

\end{lstlisting}

\noindent



\subsection{Simulation Results}



\end{document}